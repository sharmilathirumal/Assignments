Applicable Collections
----------------------
Unlike ListIterator, Iterator can be used on any Collection (List, Set, Queue, Deque, Map‚Äôs keySet/values/entrySet).
Example: HashSet, TreeSet, PriorityQueue, ArrayDeque, HashMap.entrySet().

Methods in Iterator
-------------------
hasNext() ‚Üí checks if more elements are available.
next() ‚Üí returns next element, throws NoSuchElementException if none.
remove() ‚Üí removes last element returned by next().

Limitations of Iterator
-----------------------
Forward-only traversal (can‚Äôt go backward).
Doesn‚Äôt provide index info (you don‚Äôt know the position of elements).
No add() or set() (only supports deletion).
One-time use ‚Üí cannot be reset, need to recreate.

Fail-Fast Iterators
-------------------
Already covered in your notes üëç, but highlight:
Fail-fast iterators (like in ArrayList, HashMap) throw ConcurrentModificationException on structural modification.
Fail-safe iterators (like in ConcurrentHashMap, CopyOnWriteArrayList) do not throw ‚Üí instead they operate on a snapshot copy.

Exceptions in Iterator
-----------------------
NoSuchElementException ‚Üí when calling next() after the end.
IllegalStateException ‚Üí when calling remove() without first calling next().
When to Use Iterator vs Alternatives
Use Iterator ‚Üí when you want a generic way to traverse any collection.
Use ListIterator ‚Üí when working with Lists and need bidirectional traversal or CRUD operations.
Use for-each loop / streams ‚Üí when you only need read-only traversal